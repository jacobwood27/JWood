<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Superbowl Squares</title> <header> <div class=blog-name ><a href="/">Jacob Wood</a></div> <nav> <ul> <li><a href="/projects/">Projects</a> <li><a href="/projects/books/">Books</a> <li><a href="/projects/inklings/">Inklings</a> <li><a href="/now">Now</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><p>You know that game everyone plays when watching the Superbowl? Where you buy a square for a dollar and then if the two last digits of the score at the end of the quarter end up corresponding to your square you win some money?</p> <div class=im-100 ><img src="/projects/superbowl_squares/sb_squares.jpg" alt=""></div> <p>The numbers assigned to the rows and columns are typically randomly generated after all the squares are purchased, so the best squares like &#40;0,0&#41;, &#40;7,0&#41; and &#40;0,7&#41;, can&#39;t be knowingly purchased. </p> <p>The random assignment prevents there from being any strategy involved with the selection of any one square. However, when purchasing multiple squares, you have the choice to buy your additional squares in a common row or column. </p> <p>This project attempts to see what sort of statistical edge you might be able to glean from strategically purchasing multiple squares at your next Superbowl party.</p> <h2 id=data ><a href="#data" class=header-anchor >Data</a></h2> <h3 id=model ><a href="#model" class=header-anchor >Model</a></h3> <p>Our ideal model determines, for both teams, the probability distribution over the following 5 possible outcomes:</p> <ul> <li><p>ABCD - Different final digits for each quarter <em>&#40;e.g. 0,7,14,21&#41;</em></p> <li><p>AABC - 2 quarters share a final digit <em>&#40;e.g. 0,10,17,23&#41;</em></p> <li><p>AABB - 2 pairs of quarters share a final digit <em>&#40;e.g. 0,7,17,20&#41;</em></p> <li><p>AAAB - 3 quarters share a final digit <em>&#40;e.g. 7,10,17,17&#41;</em></p> <li><p>AAAA - All 4 quarters share a final digit <em>&#40;e.g. 0,10,10,20&#41;</em></p> </ul> <p>To simplify the problem we will use only the predicted final score as input to the model. This will cause us to miss any distinctive scoring characteristics &#40;maybe this team never scores in the 3rd quarter&#41; but we should capture the bulk of the predictive power. The best predictive data we will have should come from the Vegas betting line, which <a href="https://en.wikipedia.org/wiki/Efficient-market_hypothesis">theoretically</a> does all the modeling and predictive work for us. We will use the Over/Under and the spread to back out the implied point totals for both teams and use that as model inputs.</p> <p>The historic data we will need to build the model thus looks something like &#40;using the <a href="https://www.pro-football-reference.com/boxscores/202102070tam.htm">2020 Superbowl</a> as an example&#41;:</p> <div class=books-page ><table><tr><th align=right >GameID<th align=right >Team<th align=right >O/U<th align=right >Spread<th align=right >Q1<th align=right >Q2<th align=right >Q3<th align=right >End<th align=right >Implied Total<th align=right >ABCD<th align=right >AABC<th align=right >AABB<th align=right >AAAB<th align=right >AAAA<tr><td align=right >202102070tam<td align=right >tam<td align=right >54.5<td align=right >3<td align=right >7<td align=right >21<td align=right >31<td align=right >31<td align=right >25.75<td align=right >false<td align=right >false<td align=right >false<td align=right >true<td align=right >false<tr><td align=right >202102070tam<td align=right >kan<td align=right >54.5<td align=right >-3<td align=right >3<td align=right >6<td align=right >9<td align=right >9<td align=right >28.75<td align=right >false<td align=right >true<td align=right >false<td align=right >false<td align=right >false</table></div> <h3 id=scraping ><a href="#scraping" class=header-anchor >Scraping</a></h3> <p>For some reason I could not find quarter-by-quarter scores of all historic NFL games as a tidy dataset anywhere. An excellent site <a href="https://www.pro-football-reference.com">https://www.pro-football-reference.com</a> has all the desired information embedded in webpages that we can scrape.</p> <p>Pro-football-reference has quarter-by-quarter scores available going back to <a href="https://www.pro-football-reference.com/boxscores/192009260rii.htm">1920</a> and Vegas lines with a recorded spread and over/under going back to <a href="https://www.pro-football-reference.com/teams/det/1979_lines.htm">1979</a>. We will scrape all the games from 1979 to the present day.</p> <p>In Julia webscraping can be done with the help of <a href="https://github.com/JuliaWeb/HTTP.jl">HTTP.jl</a>, <a href="https://github.com/JuliaWeb/Gumbo.jl">Gumbo.jl</a>, and <a href="https://github.com/Algocircle/Cascadia.jl">Cascadia.jl</a>. </p> <p>The scraping is performed in two passes, one to gather all the quarter scores and one to append all the Vegas lines. </p> <p>To gather the quarter scores we follow <a href="https://github.com/jacobwood27/017_nflsquares/blob/main/scrape_scores.jl">this algorithm</a>:</p> <ul> <li><p>For each year in 1979-2020 &#40;in parallel&#41;:</p> <ul> <li><p>Read <a href="https://www.pro-football-reference.com/years/1979/">https://www.pro-football-reference.com/years/&#36;YEAR/</a></p> <li><p>Find the weeks games were played from the Week Summaries buttons halfway down the page</p> <li><p>For each week:</p> <ul> <li><p>Read <a href="https://www.pro-football-reference.com/years/1979/week_1.htm">https://www.pro-football-reference.com/years/&#36;YEAR/week_&#36;WEEK.htm</a></p> <li><p>Find all the &quot;Final&quot; Links for the displayed games</p> <li><p>For each game:</p> <ul> <li><p>Read <a href="https://www.pro-football-reference.com/boxscores/197909010tam.htm">https://www.pro-football-reference.com/boxscores/&#36;GAMEID.htm</a></p> <li><p>Find the first 3 quarter scores and the final score &#40;ignore 4th quarter and overtime&#41;</p> <li><p>Write a line into the resulting .csv file for both teams</p> </ul> </ul> </ul> </ul> <p>To append the Vegas lines to the table we follow <a href="https://github.com/jacobwood27/017_nflsquares/blob/main/scrape_odds.jl">this algorithm</a>:</p> <ul> <li><p>For each row in the data:</p> <ul> <li><p>If the row is not yet populated with lines:</p> <ul> <li><p>Read <a href="https://www.pro-football-reference.com/teams/det/1979_lines.htm">https://www.pro-football-reference.com/teams/&#36;TEAM/&#36;YEAR_lines.htm</a></p> <li><p>Find all the rows in the &quot;Vegas Lines&quot; table</p> <li><p>For each row:</p> <ul> <li><p>Read the spread</p> <li><p>Read the over/under</p> <li><p>Find the matching gameID and TeamID in the data and record the spread and over/under</p> </ul> </ul> </ul> </ul> <p>And then for final data preparation:</p> <ul> <li><p>Sort by GameID</p> <li><p>Make the quarter results cumulative</p> <li><p>Remove the ~50 games where the over/under wasn&#39;t recorded</p> <li><p>Calculate the implied points total for each row</p> <li><p>One hot encode the quarter by quarter results into our 5 categories</p> </ul> <p>Our resulting data has 20936 rows and looks like:</p> <div class=books-page ><table><tr><th align=right >year<th align=right >week<th align=right >id<th align=right >team<th align=right >opp<th align=right >q1<th align=right >q2<th align=right >q3<th align=right >final<th align=right >spread<th align=right >OU<th align=right >imp_tot<th align=right >ABCD<th align=right >AABC<th align=right >AABB<th align=right >AAAB<th align=right >AAAA<tr><td align=right >1979<td align=right >1<td align=right >197909010tam<td align=right >det<td align=right >tam<td align=right >0<td align=right >7<td align=right >7<td align=right >16<td align=right >3.0<td align=right >30.0<td align=right >13.5<td align=right >false<td align=right >true<td align=right >false<td align=right >false<td align=right >false<tr><td align=right >1979<td align=right >1<td align=right >197909010tam<td align=right >tam<td align=right >det<td align=right >10<td align=right >24<td align=right >24<td align=right >31<td align=right >-3.0<td align=right >30.0<td align=right >16.5<td align=right >false<td align=right >true<td align=right >false<td align=right >false<td align=right >false<tr><td align=right >1979<td align=right >1<td align=right >197909020buf<td align=right >mia<td align=right >buf<td align=right >0<td align=right >0<td align=right >3<td align=right >9<td align=right >-5.0<td align=right >39.0<td align=right >22.0<td align=right >false<td align=right >true<td align=right >false<td align=right >false<td align=right >false<tr><td align=right >1979<td align=right >1<td align=right >197909020buf<td align=right >buf<td align=right >mia<td align=right >0<td align=right >7<td align=right >7<td align=right >7<td align=right >5.0<td align=right >39.0<td align=right >17.0<td align=right >false<td align=right >false<td align=right >false<td align=right >true<td align=right >false<tr><td align=right >1979<td align=right >1<td align=right >197909020chi<td align=right >gnb<td align=right >chi<td align=right >0<td align=right >0<td align=right >3<td align=right >3<td align=right >3.0<td align=right >31.0<td align=right >14.0<td align=right >false<td align=right >false<td align=right >true<td align=right >false<td align=right >false<tr><td align=right >1979<td align=right >1<td align=right >197909020chi<td align=right >chi<td align=right >gnb<td align=right >0<td align=right >6<td align=right >6<td align=right >6<td align=right >-3.0<td align=right >31.0<td align=right >17.0<td align=right >false<td align=right >false<td align=right >false<td align=right >true<td align=right >false</table></div> <p>There is some interesting visualization we can do here. The actual total score and the predicted total score share the same median value &#40;21&#41; but the actual distribution has for more variance and is clumped around typical football scores.</p> <img src="/projects/superbowl_squares/score_histogram.png" alt=""> <p>Turns out the betting lines are pretty good; the linear regression between the predicted and the actual score has a slope of 0.97 and an intercept &lt;1.0.</p> <img src="/projects/superbowl_squares/score_heatmap.png" alt=""> <p>What we really care about is how well the predicted score identifies the correct category.</p> <p><img src="/projects/superbowl_squares/outcome_fill.png" alt=""> <img src="/projects/superbowl_squares/outcome_line.png" alt=""></p> <p>The results are impressively smooth and continuous. They generally follow some naive expectations: as the predicted score gets higher it becomes more and more likely that we end in higher variance outcomes, like <em>ABCD</em> or <em>AABC</em>, and less likely that we end in lower variance outcomes like <em>AAAA</em>.</p> <p>Applied to the 2020 Superbowl, we can read out:</p> <table><tr><th align=right >team<th align=right >spread<th align=right >OU<th align=right >imp_tot<th align=right >P&#40;ABCD&#41;<th align=right >P&#40;AABC&#41;<th align=right >P&#40;AABB&#41;<th align=right >P&#40;AAAB&#41;<th align=right >P&#40;AAAA&#41;<tr><td align=right >tam<td align=right >3.0<td align=right >54.5<td align=right >25.75<td align=right >0.14<td align=right >0.48<td align=right >0.13<td align=right >0.22<td align=right >0.03<tr><td align=right >kan<td align=right >-3.0<td align=right >54.5<td align=right >28.75<td align=right >0.19<td align=right >0.46<td align=right >0.11<td align=right >0.21<td align=right >0.03</table> <p>We now have a model that takes in the Vegas lines and returns the probability distribution across the 5 outcomes that we care about for square picking. Let&#39;s see what we can do with it&#33;</p> <h2 id=simulation ><a href="#simulation" class=header-anchor >Simulation</a></h2> <p>In Julia we can write a simple Monte Carlo simulation to play out many versions of the big game and see how well our bets score.</p> <p>Each outcome will return 4 1-10 coordinates corresponsing to the row/column for each quarter.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> StatsBase

<span class=hljs-keyword >function</span> ABCD()
    x = sample(<span class=hljs-number >1</span>:<span class=hljs-number >10</span>, <span class=hljs-number >4</span>, replace=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >return</span> [x[<span class=hljs-number >1</span>],x[<span class=hljs-number >2</span>],x[<span class=hljs-number >3</span>],x[<span class=hljs-number >4</span>]]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> AABC()
    x = sample(<span class=hljs-number >1</span>:<span class=hljs-number >10</span>, <span class=hljs-number >3</span>, replace=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >return</span> [x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>],x[<span class=hljs-number >2</span>],x[<span class=hljs-number >3</span>]]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> AABB()
    x = sample(<span class=hljs-number >1</span>:<span class=hljs-number >10</span>, <span class=hljs-number >2</span>, replace=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >return</span> [x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>],x[<span class=hljs-number >2</span>],x[<span class=hljs-number >2</span>]]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> AAAB()
    x = sample(<span class=hljs-number >1</span>:<span class=hljs-number >10</span>, <span class=hljs-number >2</span>, replace=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >return</span> [x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>],x[<span class=hljs-number >2</span>]]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> AAAA()
    x = sample(<span class=hljs-number >1</span>:<span class=hljs-number >10</span>, <span class=hljs-number >1</span>, replace=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >return</span> [x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>],x[<span class=hljs-number >1</span>]]
<span class=hljs-keyword >end</span></code></pre> <p>We will roll against the probability distribution to see which outcome is randomly selected.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> get_outcome(P)
    roll = rand()
    <span class=hljs-keyword >if</span> roll &lt; P[<span class=hljs-number >1</span>]
        <span class=hljs-keyword >return</span> ABCD()
    <span class=hljs-keyword >elseif</span> roll &lt; P[<span class=hljs-number >1</span>] + P[<span class=hljs-number >2</span>]
        <span class=hljs-keyword >return</span> AABC()
    <span class=hljs-keyword >elseif</span> roll &lt; P[<span class=hljs-number >1</span>] + P[<span class=hljs-number >2</span>] + P[<span class=hljs-number >3</span>]
        <span class=hljs-keyword >return</span> AABB()
    <span class=hljs-keyword >elseif</span> roll &lt; P[<span class=hljs-number >1</span>] + P[<span class=hljs-number >2</span>] + P[<span class=hljs-number >3</span>] + P[<span class=hljs-number >4</span>]
        <span class=hljs-keyword >return</span> AAAB()
    <span class=hljs-keyword >else</span> 
        <span class=hljs-keyword >return</span> AAAA()
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <p>And the simulation will be run by comparing the random results to a vector of input coordinates. We can use multiple threads &#40;make sure to use an atomic for the variable that is shared across threads&#41; to speed things up.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sim(coords, P1, P2; N=<span class=hljs-number >10000000</span>)
    winnings = Threads.Atomic{<span class=hljs-built_in >Int</span>}(<span class=hljs-number >0</span>)
    payoff = <span class=hljs-number >25</span>
    Threads.<span class=hljs-meta >@threads</span> <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:N

        t1 = get_outcome(P1)
        t2 = get_outcome(P2)

        <span class=hljs-keyword >for</span> j=<span class=hljs-number >1</span>:<span class=hljs-number >4</span>
            <span class=hljs-keyword >for</span> c <span class=hljs-keyword >in</span> coords
                <span class=hljs-keyword >if</span> t1[j]==c[<span class=hljs-number >1</span>] &amp;&amp; t2[j]==c[<span class=hljs-number >2</span>]
                    Threads.atomic_add!(winnings, payoff)
                    <span class=hljs-keyword >break</span>
                <span class=hljs-keyword >end</span>
            <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >end</span> 

    <span class=hljs-keyword >end</span>

    println()
    println(<span class=hljs-string >&quot;After <span class=hljs-variable >$N</span> runs:&quot;</span>)
    println(<span class=hljs-string >&quot;Expected return on \$<span class=hljs-subst >$(length(coords)</span>) = \$<span class=hljs-subst >$(winnings[]/N)</span>&quot;</span>)
    println()

    <span class=hljs-keyword >return</span> winnings[]/length(coords)/N
<span class=hljs-keyword >end</span></code></pre> <h3 id=with_1_square ><a href="#with_1_square" class=header-anchor >With 1 Square</a></h3> <p>We can simulate the results with a single square to verify the expected return is neutral:</p> <pre><code class="julia hljs">P1 = [<span class=hljs-number >0.14</span>, <span class=hljs-number >0.48</span>, <span class=hljs-number >0.13</span>, <span class=hljs-number >0.22</span>, <span class=hljs-number >0.03</span>]
P2 = [<span class=hljs-number >0.19</span>, <span class=hljs-number >0.46</span>, <span class=hljs-number >0.11</span>, <span class=hljs-number >0.21</span>, <span class=hljs-number >0.03</span>]
C = [(<span class=hljs-number >4</span>,<span class=hljs-number >8</span>)]
sim(C, P1, P2)</code></pre> <pre><code class="plaintext hljs">After 10000000 runs:
Expected return on $1 = $0.999695</code></pre> <h3 id=with_2_squares ><a href="#with_2_squares" class=header-anchor >With 2 Squares</a></h3> <p>Two purchased squares can be aligned in 3 distinct ways:</p> <p>✅✅ | ✅⬜ | ✅⬜<br/> ⬜⬜ | ✅⬜ | ⬜✅</p> <pre><code class="julia hljs">P1 = [<span class=hljs-number >0.14</span>, <span class=hljs-number >0.48</span>, <span class=hljs-number >0.13</span>, <span class=hljs-number >0.22</span>, <span class=hljs-number >0.03</span>]
P2 = [<span class=hljs-number >0.19</span>, <span class=hljs-number >0.46</span>, <span class=hljs-number >0.11</span>, <span class=hljs-number >0.21</span>, <span class=hljs-number >0.03</span>]
C = [   [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >1</span>,<span class=hljs-number >2</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >1</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >2</span>)]
    ]
[sim(c, P1, P2) <span class=hljs-keyword >for</span> c <span class=hljs-keyword >in</span> C]</code></pre> <pre><code class="plaintext hljs">Expected return on $2 = $1.9988025

Expected return on $2 = $1.9997625

Expected return on $2 = $2.0050025</code></pre> <p>Hmm, no meaningful variation across those runs.</p> <h3 id=with_3_squares ><a href="#with_3_squares" class=header-anchor >With 3 Squares</a></h3> <p>Three purchased squares can be aligned in 6 distinct ways:</p> <p>✅✅✅ | ✅✅⬜ | ✅✅⬜ | ✅⬜⬜ | ✅⬜⬜ | ✅⬜⬜<br/> ⬜⬜⬜ | ⬜⬜✅ | ✅⬜⬜ | ✅⬜⬜ | ✅⬜⬜ | ⬜✅⬜<br/> ⬜⬜⬜ | ⬜⬜⬜ | ⬜⬜⬜ | ⬜✅⬜ | ✅⬜⬜ | ⬜⬜✅</p> <pre><code class="julia hljs">P1 = [<span class=hljs-number >0.14</span>, <span class=hljs-number >0.48</span>, <span class=hljs-number >0.13</span>, <span class=hljs-number >0.22</span>, <span class=hljs-number >0.03</span>]
P2 = [<span class=hljs-number >0.19</span>, <span class=hljs-number >0.46</span>, <span class=hljs-number >0.11</span>, <span class=hljs-number >0.21</span>, <span class=hljs-number >0.03</span>]
C = [   [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >1</span>,<span class=hljs-number >2</span>), (<span class=hljs-number >1</span>,<span class=hljs-number >3</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >1</span>,<span class=hljs-number >2</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >3</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >1</span>,<span class=hljs-number >2</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >1</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >3</span>,<span class=hljs-number >2</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >3</span>,<span class=hljs-number >1</span>)],
        [(<span class=hljs-number >1</span>,<span class=hljs-number >1</span>), (<span class=hljs-number >2</span>,<span class=hljs-number >2</span>), (<span class=hljs-number >3</span>,<span class=hljs-number >3</span>)],
    ]
[sim(c, P1, P2) <span class=hljs-keyword >for</span> c <span class=hljs-keyword >in</span> C]</code></pre> <pre><code class="plaintext hljs">Expected return on $3 = $2.9988275

Expected return on $3 = $3.005655

Expected return on $3 = $2.99696

Expected return on $3 = $2.9966

Expected return on $3 = $2.999255

Expected return on $3 = $3.001155</code></pre> <p>Still no variation in the results&#33;</p> <h2 id=results ><a href="#results" class=header-anchor >Results</a></h2> <p>We can poke around with more purchased squares, we can change the predicted score categories, but the answer remains the same: you cannot buy squares in a strategic way. </p> <p>In retrospect this makes sense. Any shifting of strategy is necessarily sacrificing likelihood for payoff. If you stack everything in one column you improve the expected return conditional on winning at least once, but decrease the probability of winning at least once.</p> <p>Go ahead and pick whatever squares feel lucky to you, we can&#39;t beat the odds here&#33;</p> <div class=page-foot > <div class=copyright > Last modified: October 18, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div>